
// Generated by CoffeeScript 1.6.3
define('editor_tools/scriptable_toolbar',['require'],function(require) {
  var $, ScriptableToolbar;
  if (typeof $ === "undefined" || $ === null) {
    $ = jQuery;
  }
  return ScriptableToolbar = (function() {
    function ScriptableToolbar(parent, interpreter, root_path) {
      this.interpreter = interpreter;
      this.root_path = root_path;
      this.menuMap = {};
      this.initVisual(parent);
    }

    ScriptableToolbar.prototype.addItem = function(section, itemName, imghRef, helpText, clear) {
      var item, me;
      if (helpText == null) {
        helpText = "";
      }
      if (clear == null) {
        clear = false;
      }
      me = this;
      item = $("<div>").addClass("ribbon-button").attr("style", "float:left");
      if (clear) {
        item.attr("style", item.attr("style") + ";clear:both");
      }
      item.append($("<span>").addClass("button-help").text(helpText));
      item.append($("<img>").addClass("ribbon-icon").attr("src", this.root_path + imghRef));
      $(item).click(function() {
        var impl;
        impl = me.interpreter.getImplementation(itemName);
        if (impl == null) {
          return;
        }
        return impl();
      });
      $(item).mousedown(function(evt) {
        if (evt.which !== 3) {
          return;
        }
        return console.log(itemName);
      });
      return section["__itemRoot__"].append(item);
    };

    ScriptableToolbar.prototype.addSection = function(menu, sectionName) {
      var itemRoot;
      if (menu[sectionName] != null) {
        return menu[sectionName];
      }
      itemRoot = $("<div>").addClass("ribbon-section");
      itemRoot.append($("<span>").addClass("section-title").text(sectionName));
      menu["__sectionRoot__"].append(itemRoot);
      return menu[sectionName] = {
        __itemRoot__: itemRoot
      };
    };

    ScriptableToolbar.prototype.addMenu = function(name) {
      var tab;
      if (this.menuMap[name] != null) {
        return this.menuMap[name];
      }
      tab = $("<div>").addClass("ribbon-tab");
      tab.append($("<span>").addClass("ribbon-title").text(name));
      this.ribbon.append(tab);
      return this.menuMap[name] = {
        __sectionRoot__: tab
      };
    };

    ScriptableToolbar.prototype.initVisual = function(parent) {
      this.ribbon = $("<div>").addClass("ribbon").append($("<span>").addClass("ribbon-window-title"));
      return parent.append(this.ribbon);
    };

    ScriptableToolbar.prototype.loadLayout = function(data) {
      var itemData, itemName, menu, menuData, name, section, sectionData, sectionName;
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      for (name in data) {
        menuData = data[name];
        menu = this.addMenu(name);
        for (sectionName in menuData) {
          sectionData = menuData[sectionName];
          section = this.addSection(menu, sectionName);
          for (itemName in sectionData) {
            itemData = sectionData[itemName];
            this.addItem(section, itemName, itemData["href"], itemData["help"], itemData["clear"]);
          }
        }
      }
      return null;
    };

    return ScriptableToolbar;

  })();
});

// Generated by CoffeeScript 1.6.3
define('editor_tools/interpretter',['require'],function(req) {
  var Interpreter;
  return Interpreter = (function() {
    function Interpreter(editor) {
      var _this;
      this.editor = editor;
      _this = this;
      this.env = {};
    }

    Interpreter.prototype.hasImplementation = function(item) {
      return this.env[item] != null;
    };

    Interpreter.prototype.getImplementation = function(cmd) {
      return this.env[cmd];
    };

    Interpreter.prototype.exec = function(script) {
      var e, s;
      try {
        eval("with (this.env) { script(); }");
      } catch (_error) {
        e = _error;
        s = e;
      }
      if ((s != null) && (s.toString != null)) {
        return s.toString();
      }
    };

    Interpreter.prototype.autocomplete = function(string, callback) {
      var prop, results;
      results = [];
      for (prop in this.env) {
        if (prop.indexOf(string) === 0) {
          results.push(prop);
        }
      }
      return callback(results);
    };

    Interpreter.prototype.loadScript = function(editor, env, api) {
      return function(t) {
        return env[api] = function() {
          return t(editor);
        };
      };
    };

    Interpreter.prototype.loadAPI = function(data) {
      var api, editor, env, prop, r;
      if (typeof data === "string") {
        data = JSON.parse(data);
      }
      env = this.env;
      editor = this.editor;
      for (prop in data) {
        api = "scripts/" + prop + "-" + data[prop]["repo"] + "-" + data[prop]["version"] + ".js";
        r = require([require.toUrl(api)], this.loadScript(editor, env, prop));
      }
      return env;
    };

    return Interpreter;

  })();
});

// Generated by CoffeeScript 1.3.3
(function() {
  var Byte, Client, Frame, Stomp,
    __hasProp = {}.hasOwnProperty;

  Byte = {
    LF: '\x0A',
    NULL: '\x00'
  };

  Frame = (function() {

    function Frame(command, headers, body) {
      this.command = command;
      this.headers = headers != null ? headers : {};
      this.body = body != null ? body : '';
    }

    Frame.prototype.toString = function() {
      var lines, name, value, _ref;
      lines = [this.command];
      _ref = this.headers;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        lines.push("" + name + ":" + value);
      }
      if (this.body) {
        lines.push("content-length:" + ('' + this.body).length);
      }
      lines.push(Byte.LF + this.body);
      return lines.join(Byte.LF);
    };

    Frame._unmarshallSingle = function(data) {
      var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _ref, _ref1;
      divider = data.search(RegExp("" + Byte.LF + Byte.LF));
      headerLines = data.substring(0, divider).split(Byte.LF);
      command = headerLines.shift();
      headers = {};
      trim = function(str) {
        return str.replace(/^\s+|\s+$/g, '');
      };
      line = idx = null;
      for (i = _i = 0, _ref = headerLines.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = headerLines[i];
        idx = line.indexOf(':');
        headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
      }
      body = '';
      start = divider + 2;
      if (headers['content-length']) {
        len = parseInt(headers['content-length']);
        body = ('' + data).substring(start, start + len);
      } else {
        chr = null;
        for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
          chr = data.charAt(i);
          if (chr === Byte.NULL) {
            break;
          }
          body += chr;
        }
      }
      return new Frame(command, headers, body);
    };

    Frame.unmarshall = function(datas) {
      var data;
      return (function() {
        var _i, _len, _ref, _results;
        _ref = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          data = _ref[_i];
          if ((data != null ? data.length : void 0) > 0) {
            _results.push(Frame._unmarshallSingle(data));
          }
        }
        return _results;
      })();
    };

    Frame.marshall = function(command, headers, body) {
      var frame;
      frame = new Frame(command, headers, body);
      return frame.toString() + Byte.NULL;
    };

    return Frame;

  })();

  Client = (function() {

    function Client(ws) {
      this.ws = ws;
      this.ws.binaryType = "arraybuffer";
      this.counter = 0;
      this.connected = false;
      this.heartbeat = {
        outgoing: 10000,
        incoming: 10000
      };
      this.subscriptions = {};
    }

    Client.prototype._transmit = function(command, headers, body) {
      var out;
      out = Frame.marshall(command, headers, body);
      if (typeof this.debug === "function") {
        this.debug(">>> " + out);
      }
      return this.ws.send(out);
    };

    Client.prototype._setupHeartbeat = function(headers) {
      var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1,
        _this = this;
      if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
        return;
      }
      _ref1 = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = headers['heart-beat'].split(",");
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          v = _ref1[_i];
          _results.push(parseInt(v));
        }
        return _results;
      })(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
      if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
        ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
        if (typeof this.debug === "function") {
          this.debug("send PING every " + ttl + "ms");
        }
        this.pinger = typeof window !== "undefined" && window !== null ? window.setInterval(function() {
          _this.ws.send(Byte.LF);
          return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
        }, ttl) : void 0;
      }
      if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
        ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
        if (typeof this.debug === "function") {
          this.debug("check PONG every " + ttl + "ms");
        }
        return this.ponger = typeof window !== "undefined" && window !== null ? window.setInterval(function() {
          var delta;
          delta = Date.now() - _this.serverActivity;
          if (delta > ttl * 2) {
            if (typeof _this.debug === "function") {
              _this.debug("did not receive server activity for the last " + delta + "ms");
            }
            return _this._cleanUp();
          }
        }, ttl) : void 0;
      }
    };

    Client.prototype.connect = function(login, passcode, connectCallback, errorCallback, vhost) {
      var _this = this;
      this.connectCallback = connectCallback;
      if (typeof this.debug === "function") {
        this.debug("Opening Web Socket...");
      }
      this.ws.onmessage = function(evt) {
        var arr, c, data, frame, onreceive, _i, _len, _ref, _results;
        data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, ((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arr.length; _i < _len; _i++) {
            c = arr[_i];
            _results.push(String.fromCharCode(c));
          }
          return _results;
        })()).join('')) : evt.data;
        _this.serverActivity = Date.now();
        if (data === Byte.LF) {
          if (typeof _this.debug === "function") {
            _this.debug("<<< PONG");
          }
          return;
        }
        if (typeof _this.debug === "function") {
          _this.debug("<<< " + data);
        }
        _ref = Frame.unmarshall(data);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          frame = _ref[_i];
          switch (frame.command) {
            case "CONNECTED":
              if (typeof _this.debug === "function") {
                _this.debug("connected to server " + frame.headers.server);
              }
              _this.connected = true;
              _this._setupHeartbeat(frame.headers);
              _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
              break;
            case "MESSAGE":
              onreceive = _this.subscriptions[frame.headers.subscription];
              _results.push(typeof onreceive === "function" ? onreceive(frame) : void 0);
              break;
            case "RECEIPT":
              _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
              break;
            case "ERROR":
              _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
              break;
            default:
              _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
          }
        }
        return _results;
      };
      this.ws.onclose = function() {
        var msg;
        msg = "Whoops! Lost connection to " + _this.ws.url;
        if (typeof _this.debug === "function") {
          _this.debug(msg);
        }
        return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
      };
      return this.ws.onopen = function() {
        var headers;
        if (typeof _this.debug === "function") {
          _this.debug('Web Socket Opened...');
        }
        headers = {
          "accept-version": Stomp.VERSIONS.supportedVersions(),
          "heart-beat": [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',')
        };
        if (vhost) {
          headers.host = vhost;
        }
        if (login) {
          headers.login = login;
        }
        if (passcode) {
          headers.passcode = passcode;
        }
        return _this._transmit("CONNECT", headers);
      };
    };

    Client.prototype.disconnect = function(disconnectCallback) {
      this._transmit("DISCONNECT");
      this.ws.onclose = null;
      this._cleanUp();
      return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
    };

    Client.prototype._cleanUp = function() {
      this.ws.close();
      this.connected = false;
      if (this.pinger) {
        if (typeof window !== "undefined" && window !== null) {
          window.clearInterval(this.pinger);
        }
      }
      if (this.ponger) {
        return typeof window !== "undefined" && window !== null ? window.clearInterval(this.ponger) : void 0;
      }
    };

    Client.prototype.send = function(destination, headers, body) {
      if (headers == null) {
        headers = {};
      }
      if (body == null) {
        body = '';
      }
      headers.destination = destination;
      return this._transmit("SEND", headers, body);
    };

    Client.prototype.subscribe = function(destination, callback, headers) {
      if (headers == null) {
        headers = {};
      }
      if (!headers.id) {
        headers.id = "sub-" + this.counter++;
      }
      headers.destination = destination;
      this.subscriptions[headers.id] = callback;
      this._transmit("SUBSCRIBE", headers);
      return headers.id;
    };

    Client.prototype.unsubscribe = function(id) {
      delete this.subscriptions[id];
      return this._transmit("UNSUBSCRIBE", {
        id: id
      });
    };

    Client.prototype.begin = function(transaction) {
      return this._transmit("BEGIN", {
        transaction: transaction
      });
    };

    Client.prototype.commit = function(transaction) {
      return this._transmit("COMMIT", {
        transaction: transaction
      });
    };

    Client.prototype.abort = function(transaction) {
      return this._transmit("ABORT", {
        transaction: transaction
      });
    };

    Client.prototype.ack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("ACK", headers);
    };

    Client.prototype.nack = function(messageID, subscription, headers) {
      if (headers == null) {
        headers = {};
      }
      headers["message-id"] = messageID;
      headers.subscription = subscription;
      return this._transmit("NACK", headers);
    };

    return Client;

  })();

  Stomp = {
    libVersion: "2.0.0-next",
    VERSIONS: {
      V1_0: '1.0',
      V1_1: '1.1',
      V1_2: '1.2',
      supportedVersions: function() {
        return '1.1,1.0';
      }
    },
    client: function(url, protocols) {
      var klass, ws;
      if (protocols == null) {
        protocols = ['v10.stomp', 'v11.stomp'];
      }
      klass = Stomp.WebSocketClass || WebSocket;
      ws = new klass(url, protocols);
      return new Client(ws);
    },
    over: function(ws) {
      return new Client(ws);
    },
    Frame: Frame
  };

  if (typeof window !== "undefined" && window !== null) {
    window.Stomp = Stomp;
  } else {
    exports.Stomp = Stomp;
    Stomp.WebSocketClass = require('./test/server.mock.js').StompServerMock;
  }

}).call(this);

define("stomp", function(){});

// Generated by CoffeeScript 1.6.3
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

define('editor_tools/main',['require','editor_tools/scriptable_toolbar','editor_tools/interpretter','stomp'],function(require) {
  var $, Interpretter, Toolbar;
  if (typeof $ === "undefined" || $ === null) {
    $ = jQuery;
  }
  Toolbar = require("editor_tools/scriptable_toolbar");
  Interpretter = require("editor_tools/interpretter");
  require("stomp");
  return {
    stompMsgHandler: function(msg) {
      var corrid, _ref;
      corrid = msg.headers["correlation-id"];
      if (typeof corrid !== "string") {
        return;
      }
      if (_ref = !corrid, __indexOf.call(this.editor.stompCorrelation, _ref) >= 0) {
        return;
      }
      this.editor.stompCorrelation[corrid](msg);
      return delete this.editor.stompCorrelation[corrid];
    },
    enrich_editor: function(editor, id, config) {
      var header, interpretter, layout, terminal, toolbar, wrapped;
      this.editor = editor;
      if (config == null) {
        config = {};
      }
      config = $.extend({
        root_path: "",
        stompUrl: "ws://localhost:61623",
        stompUser: "admin",
        stompPassword: "password"
      }, config);
      this.stompClient = Stomp.client(config.stompUrl);
      this.stompClient.connect(config.stompUser, config.stompPassword, (function(frame) {
        var privateQueue;
        privateQueue = "/queue/editor_tools_" + Math.floor(Math.random() * 100000);
        this.editor.stomp = this.stompClient;
        this.editor.stompQueue = privateQueue;
        this.editor.stompCorrelation = {};
        return this.stompClient.subscribe(privateQueue, this.stompMsgHandler.bind(this));
      }).bind(this));
      wrapped = $(id).wrap("<div>").parent();
      $(id).addClass("ui-layout-center");
      header = $("<div>").addClass("ui-layout-north");
      terminal = $("<div>").addClass("ui-layout-south");
      wrapped.prepend(header);
      wrapped.append(terminal);
      layout = null;
      interpretter = new Interpretter(this.editor);
      toolbar = new Toolbar(header, interpretter, config.root_path);
      return {
        toolbar: toolbar,
        interpretter: interpretter,
        editor: this.editor,
        header: header
      };
    }
  };
});
